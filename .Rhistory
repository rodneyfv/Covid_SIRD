arquivo_historico <- "Dados_Municipais_wide.csv"
pacote <- function(p){
if (!is.element(p, installed.packages()[,1])){
message('Pacote ',p,' nao encontrado. Instalando..')
install.packages(p, dep = TRUE)
}
message('Carregando pacote ',p)
require_worked <- try(require(p, character.only = TRUE))
if(!require_worked) {
install.packages(p, dep = TRUE)
}
}
pacote("tidyverse")
pacote("lubridate")
pacote("writexl")
pacote("httr")
pacote("readr")
pacote("readxl")
# Nome do arquivo do min. saude
arquivo_min_saude <- "HIST_PAINEL_COVIDBR_31mai2020.xlsx"
# Nome do arquivo a ser usado como historico
arquivo_historico <- "Dados_Municipais_wide.csv"
pacote <- function(p){
if (!is.element(p, installed.packages()[,1])){
message('Pacote ',p,' nao encontrado. Instalando..')
install.packages(p, dep = TRUE)
}
message('Carregando pacote ',p)
require_worked <- try(require(p, character.only = TRUE))
if(!require_worked) {
install.packages(p, dep = TRUE)
}
}
pacote("tidyverse")
pacote("lubridate")
pacote("writexl")
pacote("httr")
pacote("readr")
pacote("readxl")
# Atualizando tidyr se necessario
if(installed.packages() %>% as.data.frame %>% dplyr::filter(Package == "tidyr") %>% pull(Version) %>% as.character < "1.0") {
install.packages("tidyr")
pacote("tidyr")
}
municipais_wide <- read_csv(arquivo_historico) %>% # Dados enviados por Henrique e Iuri
dplyr::mutate(Codigo = as.character(Codigo))
df_caracteristicas_fixas <- municipais_wide %>% dplyr::select(- starts_with("casos"), - starts_with("mortes"))
populacoes <- list()
populacoes[["Brasil"]] <- df_caracteristicas_fixas$Populacao_estimada %>% sum
populacoes[["Brasil_IDH_alto"]] <- df_caracteristicas_fixas %>% dplyr::filter(Belgica == 1) %>% dplyr::pull(Populacao_estimada) %>% sum
populacoes[["Brasil_IDH_baixo"]] <- df_caracteristicas_fixas %>% dplyr::filter(Belgica == 0) %>% dplyr::pull(Populacao_estimada) %>% sum
saveRDS(populacoes, "lista_populacoes.rds")
municipais_wide_casos <- municipais_wide %>% dplyr::select(Codigo, starts_with("casos."))
municipais_wide_mortes <- municipais_wide %>% dplyr::select(Codigo, starts_with("mortes."))
mun_casos <- municipais_wide_casos %>% pivot_longer(- c(Codigo), names_to = "Data", values_to = "confirmed") %>%
dplyr::mutate(Data = Data %>% str_replace_all("casos.", "") %>% ymd)
mun <- municipais_wide_mortes %>% pivot_longer(- c(Codigo), names_to = "Data", values_to = "deaths") %>%
dplyr::mutate(Data = Data %>% str_replace_all("mortes.", "") %>% ymd) %>% full_join(mun_casos)
df_msaude <- read_excel(paste0(arquivo_min_saude), guess_max = 100000) %>% dplyr::select(Data = data, Codigo = codmun, deaths = obitosAcumulado,
Municipio = municipio,
confirmed = casosAcumulado) %>%
dplyr::mutate(Data = ymd(Data),
confirmed = as.numeric(confirmed),
deaths = as.numeric(deaths)) %>%
dplyr::filter(!is.na(Municipio)) %>% dplyr::select(-Municipio)
# Existem municípios com linhas duplicadas para uma mesma data de 30/05.
# Vamos remover agora pra seguir com a análise
tmp <- sort(unique(df_msaude$Data),decreasing = TRUE)[c(1:2)]
df_msaude <- df_msaude %>% filter(!(Data %in% tmp))
ultima_data_disponivel <- df_msaude$Data %>% max
# Vendo quais municipios nao estao indo ate a ultima data da base (possiveis erros)
codigos_com_erro <- df_msaude %>% dplyr::group_by(Codigo) %>% dplyr::summarise(menor_data = min(Data), maior_data = max(Data)) %>%
dplyr::arrange(maior_data) %>% dplyr::filter(maior_data != max(maior_data)) %>% dplyr::pull(Codigo)
message("Numero de municipios que nao vao ate o final: ", length(codigos_com_erro))
message("Valores de casos acumulados para os municipios com esse erro: ",  df_msaude %>% dplyr::filter(Codigo %in% codigos_com_erro) %>% dplyr::pull(confirmed) %>% unique %>% sort %>% paste(collapse = ", "))
message("Vou completar esses municipios repetindo o ultimo valor de casos e obitos ate a ultima data")
for(cod_ in codigos_com_erro) {
tbl_temp <- df_msaude %>% dplyr::filter(Codigo == cod_) %>% dplyr::filter(Data == max(Data)) %>% unique()
ultima_data <- tbl_temp$Data
datas_faltantes <- seq.Date(from = ultima_data + 1, to = ultima_data_disponivel, by = 1)
tbl_completando <- tibble(Data = datas_faltantes, Codigo = cod_) %>% left_join(tbl_temp %>% dplyr::select(-Data), by = "Codigo") %>%
dplyr::select(colnames(tbl_temp))
df_msaude <- rbind(df_msaude, tbl_completando)
}
df_msaude <- df_msaude %>% dplyr::arrange(Codigo, Data) # Essa base ja esta com todos os municipios indo ate a ultima data
comparacao_primeiro_dia <- df_msaude %>% dplyr::group_by(Codigo) %>%
dplyr::filter(Data == min(Data)) %>% dplyr::select(everything(), deaths_MS = deaths,
confirmed_MS = confirmed) %>% left_join(mun)
comparacao_primeiro_dia <- comparacao_primeiro_dia %>% dplyr::mutate(
check_confirmed = confirmed_MS - confirmed,
check_deaths = deaths_MS - deaths
)
# Verificano se os municipios que nem entraram, ate hoje, no do MSaude possuem um numero relevante de casos segundo Brasil.IO
mun_apenas_BrasilIO <- mun %>% dplyr::filter(!Codigo %in% unique(df_msaude$Codigo)) %>%
dplyr::group_by(Codigo) %>% dplyr::filter(Data == max(Data))  %>% dplyr::arrange(desc(confirmed))
# Dentre os municipios que estao no MS, pegando as datas anteriores as disponiveis no MS
keys_fora_do_df_msaude <- anti_join(mun %>% dplyr::filter(Codigo %in% unique(df_msaude$Codigo)) %>% dplyr::select(Codigo, Data), df_msaude %>% dplyr::select(Codigo, Data)) %>%
left_join(mun)
dados <- rbind(keys_fora_do_df_msaude, df_msaude)
dados_sem_buracos <- expand.grid(Codigo = unique(dados$Codigo), Data = unique(dados$Data)) %>%
dplyr::mutate(Codigo = as.character(Codigo), Data = ymd(Data))
buracos <- anti_join(dados_sem_buracos, dados %>% dplyr::select(Codigo, Data))
# Vou substituir os buracos pelo ultimo dado. Sao poucos confirmados e obitos nesses casos.
buracos <- buracos %>% dplyr::mutate(confirmed = NA, deaths = NA)
for(i_b in 1:nrow(buracos)) {
buracos$confirmed[i_b] <- mun %>% dplyr::filter(Codigo == buracos[i_b,]$Codigo, Data < buracos[i_b,]$Data)  %>% dplyr::pull(confirmed) %>% last %>% as.numeric
buracos$deaths[i_b] <- mun %>% dplyr::filter(Codigo == buracos[i_b,]$Codigo, Data < buracos[i_b,]$Data)  %>% dplyr::pull(deaths) %>% last %>% as.numeric
}
dados <- rbind(dados, buracos) %>% dplyr::arrange(Codigo, Data)
# Check de que nao tem mais buracos:
nrow(dados) == nrow(dados_sem_buracos)
dados_finais <- dados %>% left_join(df_caracteristicas_fixas)
saveRDS(dados_finais, "dados_por_municipio.rds")
mun_apenas_BrasilIO
pacote <- function(p){
if (!is.element(p, installed.packages()[,1])){
message('Pacote ',p,' nao encontrado. Instalando..')
install.packages(p, dep = TRUE)
}
message('Carregando pacote ',p)
require_worked <- try(require(p, character.only = TRUE))
if(!require_worked) {
install.packages(p, dep = TRUE)
}
}
pacote("tidyverse")
pacote("lubridate")
pacote("writexl")
pacote("httr")
pacote("readr")
pacote("readxl")
pacote("plotly")
calcula_estimador <- function(t_range, k_range, vetor_x, vetor_y, H) {
out_ <- rep(NA, t_range)
for(t in 1:t_range) {
numerador <- 0
denominador <- 0
for(k in 1:k_range) {
numerador <- numerador + gaussian_kernel((t - k)/H) * vetor_y[k] * vetor_x[k]
denominador <- denominador + gaussian_kernel((t - k)/H) * vetor_x[k] * vetor_x[k]
}
out_[t] <- numerador/denominador
}
return(out_)
}
gaussian_kernel <- function(x) {
(1 / (sqrt(2 * pi))) * exp(-(x^2/2))
}
estima_parametros <- function(dados, populacao, caso_corte = 50, kc = 1, kd = 1, kr = 1, expoente_H = 0.3, recuperados_sintetico = TRUE) {
y <- (dados %>% dplyr::select(x = recovered, r = recovered, d = deaths, c = confirmed) %>% as.matrix)
linha_corte <- which(y[,"c"] >= caso_corte)[1]
N <- populacao
n <- nrow(y) - linha_corte
H <- n^expoente_H
dt <- y[,"d"]/kd
ct <- y[,"c"]/kc
st <- N - ct
if(recuperados_sintetico) {
rt <- dplyr::lag(ct, 14) - dt
rt <- ifelse(is.na(rt), 0, rt)
} else {
rt <- y[,"r"]/kr
}
xt <- ct - dt - rt
dt <- dt[linha_corte:(n+linha_corte)]
st <- st[linha_corte:(n+linha_corte)]
xt <- xt[linha_corte:(n+linha_corte)]
rt <- rt[linha_corte:(n+linha_corte)]
ct <- ct[linha_corte:(n+linha_corte)]
delta_dt <- diff(dt)
delta_rt <- diff(rt)
delta_xt <- diff(xt)
delta_st <- diff(st)
mu_est <- calcula_estimador(n, n, xt[-length(xt)], delta_dt, H)
nu_est <- calcula_estimador(n, n, xt[-length(xt)], delta_rt, H)
beta_est <- - calcula_estimador(n, n, xt[-length(xt)] * st[-length(st)]/N, delta_st, H)
R_e <- beta_est / (mu_est + nu_est) * st[-length(st)]/N
return(list(nu_t = nu_est,
beta_t = beta_est,
mu_t = mu_est,
R_e = R_e,
xt = xt,
rt = rt,
st = st,
dt = dt,
primeira_data = first(dados$Data),
datas = dados$Data[linha_corte:(n+linha_corte)][-length(dados$Data[linha_corte:(n+linha_corte)])]
))
}
# Lendo os dados dos municípios
mun <- readRDS("./dados_por_municipio.rds")
View(mun)
# removendo municípios cuja soma de recuperados é NA
tmp <- mun %>% group_by(Estado,Município) %>%
summarise(soma = sum(confirmed), mort = sum(deaths),idh = IDHM_Renda[1]) %>%
filter(is.na(soma) | is.na(idh) | is.na(mort))
View(tmp)
table(tmp$Estado)
dim(tmp)[1] # número de municípios removidos
mun <- mun %>% group_by(Estado,Município) %>%
filter(!(is.element(Estado, tmp$Estado) & is.element(Município,tmp$Município))) %>%
ungroup
# selecionando e criando as variáveis que vão ser usadas no modelo
mun <- mun %>%
dplyr::group_by(Codigo) %>%
dplyr::mutate(
recovered = pmax(0, dplyr::lag(confirmed, 14) - dplyr::lag(deaths, 0)),
recovered = ifelse(is.na(recovered), 0, recovered),
infected = confirmed - deaths - recovered
) %>% ungroup %>% select(Estado,Município,Data,confirmed,deaths,recovered,
Populacao_estimada,IDHM_Renda)
# número de casos confirmados que marca o primeiro dia epidemiológico
caso_corte = 25
# tabela contendo os municípios separados por estado
EstMun <- mun %>% group_by(Estado,Município) %>% dplyr::summarise(count = n())
# lista que irá armazenar as curvas
estimadores_mun <- vector(mode = "list", length = dim(EstMun)[1])
for(i in 1:dim(EstMun)[1]){
dados_mun <- mun %>% filter(Estado==EstMun$Estado[i] & Município==EstMun$Município[i])
linha_corte <- which(dados_mun$confirmed >= caso_corte)
# se o município não tiver 25 ou mais casos confirmados em dia algum,
# linha_corte será NA, mas para obter as curvas para as duas últimas
# semanas, precisamos de pelo menos 15 dias epidemiológicos, pois uma
# diferença é tomada durante a estimação do modelo
if(is.na(linha_corte[1]) | length(linha_corte)<15){
estimadores_mun[[i]] <- list(Estado = EstMun$Estado[i], Município = EstMun$Município[i])
}else{
tmp <- estima_parametros(dados_mun,
populacao = dados_mun$Populacao_estimada[1],
caso_corte = 25,
expoente_H = 0.3,
recuperados_sintetico = TRUE)[c("nu_t", "beta_t", "mu_t", "R_e","datas")] %>%
lapply(function(x) tail(x,14))
estimadores_mun[[i]] <- append(tmp,list(Estado = rep(EstMun$Estado[i],14), Município = rep(EstMun$Município[i],14)))
}
}
# checando para quantos municípios o modelo foi estimado
tmp <- lapply(estimadores_mun, length) %>% unlist(use.names=FALSE)
table(tmp)
# usando a lista com as curvas, montamos um tibble contendo somente
# os municípios para os quais o modelo foi estimado
tmp2 <- lapply(estimadores_mun[which(tmp == 7)], as.data.frame)
estim_mun_df <- do.call("rbind",tmp2)
estim_mun_df <- mutate(estim_mun_df, Data=estim_mun_df$datas) %>%
select(-datas)
estim_mun_df <- dplyr::left_join(estim_mun_df,mun,by=c("Estado","Município","Data")) %>%
tibble
View(estim_mun_df)
rm(EstMun); rm(estimadores_mun)
# checando o número de municípios que sobraram por estado
tmp <- estim_mun_df %>% group_by(Estado,Município) %>%
dplyr::summarise(count = n())
table(tmp$Estado)
# curva dos municípios do estado usado no filtro e a respectiva
# curva média, usando a função ggploty
tmp <- estim_mun_df %>% dplyr::filter(Estado=='SAO PAULO') %>%
group_by(Estado,Data) %>%
dplyr::summarize(R_e = mean(R_e))
p <- estim_mun_df %>% dplyr::filter(Estado=='SAO PAULO') %>%
ggplot( aes(x=Data, y=R_e,color=Estado)) +
geom_line(aes(group=Município), alpha = .4) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
#  coord_cartesian( ylim = c(0, 20))
ggplotly(p)
# criando uma matriz para ser usada na função fanova.tests, tendo as
# curvas observadas nas colunas e pontos de discretização nas linhas
tmp <- mun_df_grupo %>% select(Município,Data,R_e) %>%
tidyr::spread(key = Município, value = R_e)
# criando uma variável dummy nos dados que assume 1 se o município
# tem IDH maior que a mediana e 0 caso contrário
tmp <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::summarize(med = median(IDHM_Renda)) %>%
dplyr::summarize(median(med))
mun_df_grupo <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::mutate(idh_grupo = ifelse(median(IDHM_Renda)>tmp,1,0))
View(mun_df_grupo)
# criando uma matriz para ser usada na função fanova.tests, tendo as
# curvas observadas nas colunas e pontos de discretização nas linhas
tmp <- mun_df_grupo %>% select(Município,Data,R_e) %>%
tidyr::spread(key = Município, value = R_e)
dados_fanova <- tmp %>% select(-Data) %>% as.matrix
rownames(dados_fanova) <- tmp$Data %>% as.character
# vetor com os grupos referente a cada curva observada
grupos_fanova <- mun_df_grupo %>% select(Município,idh_grupo) %>%
dplyr::group_by(Município) %>% unique %>% as.matrix
# checando se todos os grupos tem mais de duas observações (condição
# necessária para usar o pacote fdanova)
prod(table(grupos_fanova[,2])>1)
# Avaliando o efeito de IHHM_Renda
library("fdANOVA")
plotFANOVA(x = dados_fanova, group.label = grupos_fanova[,2],
means = TRUE)
fanova <- fanova.tests(x = dados_fanova,
group.label = grupos_fanova[,2], test = "FP",
parallel = TRUE, nslaves = 2)
summary(fanova)
fanova <- fanova.tests(x = dados_fanova,
group.label = grupos_fanova[,2],
parallel = TRUE, nslaves = 2)
summary(fanova)
tmp <- rnorm(1000)
quantile(tmp,.5)
median(tmp)
tmp2 <- quantile(tmp,.5)
tmp2[[1]]
tmp2[1]
tmp <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município)
View(tmp)
tmp <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::summarize(med = unique(IDHM_Renda))
# criando uma variável dummy nos dados que assume 1 se o município
# tem IDH maior que a mediana e 0 caso contrário
tmp <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::summarize(med = unique(IDHM_Renda)) %>%
dplyr::summarize(Q1 = quantile(med,.25)[[1]],
Q2 = quantile(med,.5)[[1]],
Q3 = quantile(med,.75)[[1]])
tmp
# criando uma variável dummy nos dados que assume 1 se o município
# tem IDH maior que a mediana e 0 caso contrário
tmp <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::summarize(med = median(IDHM_Renda)) %>%
dplyr::summarize(median(med))
tmp
mun_df_grupo <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::mutate(idh_grupo = ifelse(unique(IDHM_Renda)<Q1,1,
ifelse(unique(IDHM_Renda)<Q2,2,
ifelse(unique(IDHM_Renda)<Q3,3,4))))
# criando uma variável dummy nos dados que assume 1 se o município
# tem IDH maior que a mediana e 0 caso contrário
tmp <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::summarize(med = unique(IDHM_Renda)) %>%
dplyr::summarize(Q1 = quantile(med,.25)[[1]],
Q2 = quantile(med,.5)[[1]],
Q3 = quantile(med,.75)[[1]])
mun_df_grupo <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::mutate(idh_grupo = ifelse(unique(IDHM_Renda)<tmp$Q1,1,
ifelse(unique(IDHM_Renda)<tmp$Q2,2,
ifelse(unique(IDHM_Renda)<tmp$Q3,3,4))))
View(mun_df_grupo)
# criando uma variável dummy nos dados que assume 1 se o município
# tem IDH maior que a mediana e 0 caso contrário
grup_quartis <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::summarize(med = unique(IDHM_Renda)) %>%
dplyr::summarize(Q1 = quantile(med,.25)[[1]],
Q2 = quantile(med,.5)[[1]],
Q3 = quantile(med,.75)[[1]])
mun_df_grupo <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::mutate(idh_grupo = ifelse(unique(IDHM_Renda)<grup_quartis$Q1,1,
ifelse(unique(IDHM_Renda)<grup_quartis$Q2,2,
ifelse(unique(IDHM_Renda)<grup_quartis$Q3,3,4))))
View(mun_df_grupo)
# vetor com os grupos referente a cada curva observada
grupos_fanova <- mun_df_grupo %>% select(Município,idh_grupo) %>%
dplyr::group_by(Município) %>% unique %>% as.matrix
grupos_fanova[,2]
table(grupos_fanova[,2])
# checando se todos os grupos tem mais de duas observações (condição
# necessária para usar o pacote fdanova)
prod(table(grupos_fanova[,2])>1)
View(mun_df_grupo)
tmp <- mun_df_grupo %>%
group_by(Data) %>%
dplyr::summarize(R_e = mean(R_e))
p <- mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .4) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
p <- mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo))
ggplotly(p)
p <- mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=Estado)) +
geom_line(aes(group=Município), alpha = .4) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
# curva dos municípios do estado usado no filtro e a respectiva
# curva média, usando a função ggploty
tmp <- estim_mun_df %>% dplyr::filter(Estado=='SAO PAULO') %>%
group_by(Estado,Data) %>%
dplyr::summarize(R_e = mean(R_e))
p <- estim_mun_df %>% dplyr::filter(Estado=='SAO PAULO') %>%
ggplot( aes(x=Data, y=R_e,color=Estado)) +
geom_line(aes(group=Município), alpha = .4) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
#  coord_cartesian( ylim = c(0, 20))
ggplotly(p)
tmp <- mun_df_grupo %>%
group_by(Data) %>%
dplyr::summarize(R_e = mean(R_e))
tmp <- mun_df_grupo %>%
group_by(Data) %>%
dplyr::summarize(R_e = mean(R_e))
p <- mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=Estado)) +
geom_line(aes(group=Município), alpha = .4) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
p <- mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=Estado)) +
geom_line(aes(Município), alpha = .4) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
p <- mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=Estado)) +
geom_line(aes(group=Município), alpha = .4) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=Estado)) +
geom_line(aes(group=Município), alpha = .4)
mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .4)
mun_df_grupo <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::mutate(idh_grupo = ifelse(unique(IDHM_Renda)<grup_quartis$Q1,"1",
ifelse(unique(IDHM_Renda)<grup_quartis$Q2,"2",
ifelse(unique(IDHM_Renda)<grup_quartis$Q3,"3","4"))))
# vetor com os grupos referente a cada curva observada
grupos_fanova <- mun_df_grupo %>% select(Município,idh_grupo) %>%
dplyr::group_by(Município) %>% unique %>% as.matrix
table(grupos_fanova[,2])
tmp <- mun_df_grupo %>%
group_by(Data) %>%
dplyr::summarize(R_e = mean(R_e))
mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .4)
mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .4) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .6) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
p <- mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .6) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
p <- mun_df_grupo %>%
ggplot( aes(x=Data, y=R_e)) +
geom_line(aes(group=Município), alpha = .6) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
tmp <- mun_df_grupo %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Data) %>%
dplyr::summarize(R_e = mean(R_e))
p <- mun_df_grupo %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .6) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
?left_join
tmp <- mun_df_grupo %>% left_join(estim_mun_df)
tmp <- mun_df_grupo %>% left_join(estim_mun_df) %>%
dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Data) %>%
dplyr::summarize(R_e = mean(R_e))
p <- mun_df_grupo %>% left_join(estim_mun_df) %>%
dplyr::filter(Estado=='RIO DE JANEIRO') %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .6) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
tmp <- estim_mun_df %>% left_join(mun_df_grupo) %>%
dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Data) %>%
dplyr::summarize(R_e = mean(R_e))
p <- estim_mun_df %>% left_join(mun_df_grupo) %>%
dplyr::filter(Estado=='RIO DE JANEIRO') %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .6) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
mun_df_grupo <- estim_mun_df %>% dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Município) %>% dplyr::mutate(idh_grupo = ifelse(unique(IDHM_Renda)<grup_quartis$Q1,"ind<Q1",
ifelse(unique(IDHM_Renda)<grup_quartis$Q2,"Q1<ind<Q2",
ifelse(unique(IDHM_Renda)<grup_quartis$Q3,"Q2<ind<Q3","ind>Q3"))))
# vetor com os grupos referente a cada curva observada
grupos_fanova <- mun_df_grupo %>% select(Município,idh_grupo) %>%
dplyr::group_by(Município) %>% unique %>% as.matrix
# checando se todos os grupos tem mais de duas observações (condição
# necessária para usar o pacote fdanova)
prod(table(grupos_fanova[,2])>1)
table(grupos_fanova[,2])
tmp <- estim_mun_df %>% left_join(mun_df_grupo) %>%
dplyr::filter(Estado=='RIO DE JANEIRO') %>%
group_by(Data) %>%
dplyr::summarize(R_e = mean(R_e))
p <- estim_mun_df %>% left_join(mun_df_grupo) %>%
dplyr::filter(Estado=='RIO DE JANEIRO') %>%
ggplot( aes(x=Data, y=R_e,color=idh_grupo)) +
geom_line(aes(group=Município), alpha = .6) +
geom_line(data=tmp, alpha = .8, size = 1.5,color="black")
ggplotly(p)
fanova <- fanova.tests(x = dados_fanova,
group.label = grupos_fanova[,2], test = "FP",
parallel = TRUE, nslaves = 2)
summary(fanova)
require(shiny)
runApp('./shiny_mun_curvas/')
head(mun)
colnames(mun)
# Lendo os dados dos municípios
mun <- readRDS("./dados_por_municipio.rds")
colnames(mun)
runApp('./shiny_mun_curvas/')
runApp('./shiny_mun_curvas/')
